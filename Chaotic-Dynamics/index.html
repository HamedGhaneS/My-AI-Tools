<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🌀 Strange Attractors - Infinite Trajectory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a3e 100%);
            color: #e0e0e0;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #000;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #controls {
            width: 340px;
            background: rgba(26, 26, 62, 0.95);
            padding: 20px;
            overflow-y: auto;
            border-left: 2px solid #3b82f6;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
        }

        h1 {
            color: #3b82f6;
            font-size: 22px;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #888;
            font-size: 11px;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid #333;
        }

        .control-group {
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 3px solid #3b82f6;
        }

        .control-group h3 {
            color: #3b82f6;
            font-size: 13px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        label {
            display: block;
            color: #aaa;
            font-size: 11px;
            margin-bottom: 4px;
            margin-top: 8px;
        }

        select, input[type="range"], input[type="number"] {
            width: 100%;
            padding: 6px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 12px;
        }

        input[type="range"] {
            padding: 0;
            height: 6px;
        }

        input[type="color"] {
            width: 100%;
            height: 35px;
            border: 2px solid #444;
            border-radius: 5px;
            cursor: pointer;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }

        .checkbox-row label {
            margin: 0;
            flex: 1;
        }

        .value-display {
            float: right;
            color: #3b82f6;
            font-weight: bold;
            font-size: 11px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-top: 8px;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: translateY(-1px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-export {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .btn-export:hover {
            background: linear-gradient(135deg, #059669, #047857);
        }

        .btn-record {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .btn-record:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
        }

        .btn-record.recording {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .btn-clear {
            background: linear-gradient(135deg, #6b7280, #4b5563);
        }

        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 8px;
        }

        .preset-btn {
            padding: 6px;
            font-size: 10px;
            margin: 0;
        }

        #info-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid #3b82f6;
            font-size: 11px;
            max-width: 280px;
        }

        #info-overlay h2 {
            color: #3b82f6;
            font-size: 14px;
            margin-bottom: 6px;
        }

        .stats {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #3b82f6;
            font-size: 10px;
            color: #aaa;
        }

        .stats span {
            color: #3b82f6;
            font-weight: bold;
        }

        .recording-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px 40px;
            border-radius: 12px;
            border: 2px solid #ef4444;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .recording-overlay.active {
            display: block;
        }

        .recording-dot {
            width: 20px;
            height: 20px;
            background: #ef4444;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
            animation: pulse 1s infinite;
        }

        .progress-bar {
            width: 300px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin: 15px auto;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #10b981);
            width: 0%;
            transition: width 0.3s;
        }

        .initial-condition {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 6px;
            margin-top: 8px;
        }

        .initial-condition input {
            padding: 6px;
            font-size: 11px;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: #3b82f6;
            border-radius: 3px;
        }

        .info-text {
            font-size: 10px;
            color: #888;
            line-height: 1.4;
            margin-top: 8px;
            padding: 8px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 4px;
        }

        .info-text.warning {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: #f59e0b;
        }

        .info-text.success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #10b981;
        }

        .infinity-badge {
            display: inline-block;
            padding: 4px 8px;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid #8b5cf6;
            border-radius: 4px;
            font-size: 10px;
            color: #8b5cf6;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="renderCanvas"></canvas>
            <div id="info-overlay">
                <h2>🌀 Strange Attractors</h2>
                <p><strong>Current:</strong> <span id="current-attractor">Lorenz</span></p>
                <p style="margin-top: 4px; font-size: 10px; color: #888;">
                    <span id="mode-display">Infinite Mode</span>
                </p>
            </div>
            <div class="stats">
                <strong>FPS:</strong> <span id="fps">60</span> | 
                <strong>Points:</strong> <span id="point-count">0</span>
                <span id="max-display"></span>
            </div>
            <div class="recording-overlay" id="recordingOverlay">
                <div>
                    <span class="recording-dot"></span>
                    <span style="font-size: 18px; font-weight: bold; color: #ef4444;">RECORDING</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p style="color: #aaa; margin-top: 10px; font-size: 14px;">
                    <span id="recordingTime">0.0s</span> / <span id="totalTime">10s</span>
                </p>
                <p style="color: #888; font-size: 11px; margin-top: 5px;">
                    <span id="recordingStatus">Capturing frames...</span>
                </p>
            </div>
        </div>

        <div id="controls">
            <h1>🌀 Infinite Trajectory</h1>
            <p class="subtitle">Draw forever + Fast WebM export</p>

            <div class="control-group">
                <h3>∞ Trajectory Mode</h3>
                
                <div class="checkbox-row">
                    <input type="checkbox" id="infiniteMode" checked onchange="toggleInfiniteMode()">
                    <label for="infiniteMode">
                        <strong>Infinite Drawing Mode</strong>
                        <span class="infinity-badge">∞</span>
                    </label>
                </div>

                <div id="limitControls" style="display: none;">
                    <label>Max Points <span class="value-display" id="maxPointsValue">10000</span></label>
                    <input type="range" id="maxPoints" min="1000" max="50000" value="10000" step="1000" oninput="updateMaxPoints()">
                </div>

                <p class="info-text success" id="infiniteInfo">
                    ✨ Trajectory will continue drawing indefinitely until you clear it!
                </p>
            </div>

            <div class="control-group">
                <h3>🎯 Attractor System</h3>
                <select id="attractorType" onchange="changeAttractor()">
                    <option value="lorenz">Lorenz (Butterfly)</option>
                    <option value="rossler">Rössler (Spiral)</option>
                    <option value="aizawa">Aizawa (Complex)</option>
                    <option value="thomas">Thomas (Cyclic)</option>
                    <option value="halvorsen">Halvorsen (4-Wing)</option>
                    <option value="dadras">Dadras (Wings)</option>
                    <option value="chen">Chen (Scrolls)</option>
                    <option value="arneodo">Arneodo (Simple)</option>
                </select>

                <label>Initial Conditions (X, Y, Z)</label>
                <div class="initial-condition">
                    <input type="number" id="initX" value="0.1" step="0.1" placeholder="X">
                    <input type="number" id="initY" value="0" step="0.1" placeholder="Y">
                    <input type="number" id="initZ" value="0" step="0.1" placeholder="Z">
                </div>

                <div class="preset-grid">
                    <button class="preset-btn" onclick="quickSwitch('lorenz')">Lorenz</button>
                    <button class="preset-btn" onclick="quickSwitch('rossler')">Rössler</button>
                    <button class="preset-btn" onclick="quickSwitch('thomas')">Thomas</button>
                    <button class="preset-btn" onclick="quickSwitch('halvorsen')">Halvorsen</button>
                </div>
            </div>

            <div class="control-group">
                <h3>🎨 Visual Style</h3>
                
                <label>Line Width <span class="value-display" id="widthValue">2</span></label>
                <input type="range" id="lineWidth" min="1" max="6" value="2" step="0.5" oninput="updateLineWidth()">

                <label>Speed <span class="value-display" id="speedValue">1.0x</span></label>
                <input type="range" id="speed" min="0.2" max="5" value="1" step="0.2" oninput="updateSpeed()">

                <label>Rotation Speed <span class="value-display" id="rotSpeedValue">0.5</span></label>
                <input type="range" id="rotSpeed" min="0" max="2" value="0.5" step="0.1" oninput="updateRotSpeed()">
            </div>

            <div class="control-group">
                <h3>🌈 Colors</h3>
                
                <label>Color Mode</label>
                <select id="colorMode" onchange="updateColorMode()">
                    <option value="gradient">Gradient Flow</option>
                    <option value="rainbow">Rainbow</option>
                    <option value="single">Single Color</option>
                    <option value="dual">Dual Fade</option>
                </select>

                <label>Color 1</label>
                <input type="color" id="color1" value="#00d4ff" oninput="updateColors()">

                <label>Color 2</label>
                <input type="color" id="color2" value="#ff00ff" oninput="updateColors()">

                <label>Brightness <span class="value-display" id="brightnessValue">1.0</span></label>
                <input type="range" id="brightness" min="0.3" max="2" value="1" step="0.1" oninput="updateBrightness()">
            </div>

            <div class="control-group">
                <h3>🎬 Animation Controls</h3>
                <button onclick="toggleAutoRotate()">🔄 Toggle Auto-Rotate</button>
                <button class="btn-clear" onclick="resetView()">📷 Reset Camera</button>
                <button class="btn-clear" onclick="clearTrajectory()">🗑️ Clear Trajectory</button>
            </div>

            <div class="control-group">
                <h3>🎥 Record Video (WebM)</h3>
                
                <label>Duration (seconds)</label>
                <input type="number" id="recordDuration" value="10" min="1" max="120" step="1">
                
                <label>Frame Rate</label>
                <select id="recordFPS">
                    <option value="30" selected>30 FPS (Recommended)</option>
                    <option value="60">60 FPS (Smooth)</option>
                </select>

                <label>Resolution</label>
                <select id="recordResolution">
                    <option value="720">720p (Fast)</option>
                    <option value="1080" selected>1080p (HD)</option>
                </select>

                <button class="btn-record" id="recordBtn" onclick="toggleRecording()">
                    🎥 START RECORDING
                </button>

                <p class="info-text">
                    🚀 WebM format = 10x faster than GIF!
                    <br>Records evolution from initial conditions.
                </p>
            </div>

            <div class="control-group">
                <h3>📤 Export Image</h3>
                <button class="btn-export" onclick="exportImage(1080, 1080)">📷 Square (1080x1080)</button>
                <button class="btn-export" onclick="exportImage(1920, 1080)">🎬 Wide (1920x1080)</button>
                <button class="btn-export" onclick="exportImage(3840, 2160)">🖼️ 4K (3840x2160)</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        let scene, camera, renderer, line;
        let autoRotate = false;
        let rotationSpeed = 0.005;
        let currentAttractor = 'lorenz';
        let simulationSpeed = 1.0;
        let infiniteMode = true;
        let maxPoints = 10000;
        let points = [];
        let lineWidth = 2;

        // Current position
        let x = 0.1, y = 0, z = 0;

        // Color settings
        let colorMode = 'gradient';
        let color1 = new THREE.Color(0x00d4ff);
        let color2 = new THREE.Color(0xff00ff);
        let brightness = 1.0;

        // Recording state
        let isRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = 0;
        let recordingDuration = 10;
        let stream = null;

        // Attractor parameters
        const attractors = {
            lorenz: {
                step: (x, y, z, dt) => {
                    const sigma = 10, rho = 28, beta = 8/3;
                    const dx = sigma * (y - x) * dt;
                    const dy = (x * (rho - z) - y) * dt;
                    const dz = (x * y - beta * z) * dt;
                    return [x + dx, y + dy, z + dz];
                },
                scale: 0.03,
                init: [0.1, 0, 0]
            },
            rossler: {
                step: (x, y, z, dt) => {
                    const a = 0.2, b = 0.2, c = 5.7;
                    const dx = (-y - z) * dt;
                    const dy = (x + a * y) * dt;
                    const dz = (b + z * (x - c)) * dt;
                    return [x + dx, y + dy, z + dz];
                },
                scale: 0.05,
                init: [0.1, 0, 0]
            },
            aizawa: {
                step: (x, y, z, dt) => {
                    const a = 0.95, b = 0.7, c = 0.6, d = 3.5, e = 0.25, f = 0.1;
                    const dx = ((z - b) * x - d * y) * dt;
                    const dy = (d * x + (z - b) * y) * dt;
                    const dz = (c + a * z - z*z*z/3 - (x*x + y*y) * (1 + e * z) + f * z * x*x*x) * dt;
                    return [x + dx, y + dy, z + dz];
                },
                scale: 0.2,
                init: [0.1, 0, 0.1]
            },
            thomas: {
                step: (x, y, z, dt) => {
                    const b = 0.208186;
                    const dx = (Math.sin(y) - b * x) * dt;
                    const dy = (Math.sin(z) - b * y) * dt;
                    const dz = (Math.sin(x) - b * z) * dt;
                    return [x + dx, y + dy, z + dz];
                },
                scale: 0.15,
                init: [1, 1, 1]
            },
            halvorsen: {
                step: (x, y, z, dt) => {
                    const a = 1.89;
                    const dx = (-a * x - 4 * y - 4 * z - y * y) * dt;
                    const dy = (-a * y - 4 * z - 4 * x - z * z) * dt;
                    const dz = (-a * z - 4 * x - 4 * y - x * x) * dt;
                    return [x + dx, y + dy, z + dz];
                },
                scale: 0.08,
                init: [1, 0, 0]
            },
            dadras: {
                step: (x, y, z, dt) => {
                    const a = 3, b = 2.7, c = 1.7, d = 2, e = 9;
                    const dx = (y - a * x + b * y * z) * dt;
                    const dy = (c * y - x * z + z) * dt;
                    const dz = (d * x * y - e * z) * dt;
                    return [x + dx, y + dy, z + dz];
                },
                scale: 0.15,
                init: [1, 1, 1]
            },
            chen: {
                step: (x, y, z, dt) => {
                    const a = 5, b = -10, c = -0.38;
                    const dx = (a * x - y * z) * dt;
                    const dy = (b * y + x * z) * dt;
                    const dz = (c * z + x * y / 3) * dt;
                    return [x + dx, y + dy, z + dz];
                },
                scale: 0.05,
                init: [1, 1, 1]
            },
            arneodo: {
                step: (x, y, z, dt) => {
                    const a = -5.5, b = 3.5, c = -1;
                    const dx = y * dt;
                    const dy = z * dt;
                    const dz = (-a * x - b * y - z + c * x*x*x) * dt;
                    return [x + dx, y + dy, z + dz];
                },
                scale: 0.08,
                init: [0.1, 0, 0]
            }
        };

        // Initialize
        function init() {
            const canvas = document.getElementById('renderCanvas');
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.1,
                100
            );
            camera.position.set(0, 0, 5);

            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            createLine();
            setupControls();
            
            const init = attractors[currentAttractor].init;
            x = parseFloat(document.getElementById('initX').value) || init[0];
            y = parseFloat(document.getElementById('initY').value) || init[1];
            z = parseFloat(document.getElementById('initZ').value) || init[2];

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createLine() {
            // Start with a reasonable buffer size that grows as needed
            const initialSize = infiniteMode ? 50000 : maxPoints;
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(initialSize * 3);
            const colors = new Float32Array(initialSize * 3);
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                linewidth: lineWidth,
                transparent: false,
                opacity: 1.0
            });

            if (line) {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            }

            line = new THREE.Line(geometry, material);
            scene.add(line);
        }

        function expandBuffers() {
            // Double the buffer size when needed
            const currentSize = line.geometry.attributes.position.count;
            const newSize = currentSize * 2;
            
            const oldPositions = line.geometry.attributes.position.array;
            const oldColors = line.geometry.attributes.color.array;
            
            const newPositions = new Float32Array(newSize * 3);
            const newColors = new Float32Array(newSize * 3);
            
            // Copy old data
            newPositions.set(oldPositions);
            newColors.set(oldColors);
            
            line.geometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
            line.geometry.setAttribute('color', new THREE.BufferAttribute(newColors, 3));
        }

        function updateAttractor() {
            // Check if we need to stop (limited mode only)
            if (!infiniteMode && points.length >= maxPoints) return;

            // Expand buffers if needed (infinite mode)
            if (infiniteMode && points.length >= line.geometry.attributes.position.count - 100) {
                expandBuffers();
            }

            const attractor = attractors[currentAttractor];
            const dt = 0.005 * simulationSpeed;
            
            const [newX, newY, newZ] = attractor.step(x, y, z, dt);
            
            if (!isFinite(newX) || !isFinite(newY) || !isFinite(newZ)) {
                return;
            }
            
            x = newX;
            y = newY;
            z = newZ;

            const scaledPoint = new THREE.Vector3(
                x * attractor.scale,
                y * attractor.scale,
                z * attractor.scale
            );
            
            points.push(scaledPoint);
            document.getElementById('point-count').textContent = points.length.toLocaleString();

            // Update geometry
            const positions = line.geometry.attributes.position.array;
            const colorArray = line.geometry.attributes.color.array;
            
            const idx = points.length - 1;
            const point = points[idx];
            
            positions[idx * 3] = point.x;
            positions[idx * 3 + 1] = point.y;
            positions[idx * 3 + 2] = point.z;

            const t = idx / Math.max(points.length - 1, 1);
            const color = getColor(point, t);
            colorArray[idx * 3] = color.r;
            colorArray[idx * 3 + 1] = color.g;
            colorArray[idx * 3 + 2] = color.b;

            line.geometry.setDrawRange(0, points.length);
            line.geometry.attributes.position.needsUpdate = true;
            line.geometry.attributes.color.needsUpdate = true;
        }

        function getColor(point, t) {
            const color = new THREE.Color();

            switch(colorMode) {
                case 'gradient':
                    const mag = Math.sqrt(point.x*point.x + point.y*point.y + point.z*point.z);
                    const normalized = Math.min(mag * 2, 1);
                    color.lerpColors(color1, color2, normalized);
                    break;

                case 'rainbow':
                    const hue = t;
                    color.setHSL(hue, 1, 0.5);
                    break;

                case 'single':
                    color.copy(color1);
                    break;

                case 'dual':
                    color.lerpColors(color1, color2, t);
                    break;
            }

            color.multiplyScalar(brightness);
            return color;
        }

        function setupControls() {
            const canvas = renderer.domElement;
            let isDragging = false;
            let previousMouse = { x: 0, y: 0 };

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMouse = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMouse.x;
                    const deltaY = e.clientY - previousMouse.y;

                    const rotMatrix = new THREE.Matrix4();
                    rotMatrix.makeRotationY(deltaX * 0.005);
                    camera.position.applyMatrix4(rotMatrix);

                    const axis = new THREE.Vector3(1, 0, 0);
                    axis.applyMatrix4(new THREE.Matrix4().makeRotationY(
                        Math.atan2(camera.position.x, camera.position.z)
                    ));
                    rotMatrix.makeRotationAxis(axis, deltaY * 0.005);
                    camera.position.applyMatrix4(rotMatrix);

                    camera.lookAt(0, 0, 0);
                    previousMouse = { x: e.clientX, y: e.clientY };
                }
            });

            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY * 0.001;
                const direction = camera.position.clone().normalize();
                camera.position.addScaledVector(direction, delta);
                camera.position.clampLength(2, 20);
            });

            // Touch support
            let touchStart = null;
            canvas.addEventListener('touchstart', (e) => {
                touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            });

            canvas.addEventListener('touchmove', (e) => {
                if (touchStart) {
                    const deltaX = e.touches[0].clientX - touchStart.x;
                    const rotMatrix = new THREE.Matrix4();
                    rotMatrix.makeRotationY(deltaX * 0.005);
                    camera.position.applyMatrix4(rotMatrix);
                    camera.lookAt(0, 0, 0);
                    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            });

            canvas.addEventListener('touchend', () => touchStart = null);
        }

        // Animation loop
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;

        function animate() {
            requestAnimationFrame(animate);

            const stepsPerFrame = Math.max(1, Math.floor(simulationSpeed * 3));
            for (let i = 0; i < stepsPerFrame; i++) {
                updateAttractor();
            }

            if (autoRotate) {
                const rotMatrix = new THREE.Matrix4();
                rotMatrix.makeRotationY(rotationSpeed);
                camera.position.applyMatrix4(rotMatrix);
                camera.lookAt(0, 0, 0);
            }

            renderer.render(scene, camera);

            // Update recording time
            if (isRecording) {
                const elapsed = (performance.now() - recordingStartTime) / 1000;
                document.getElementById('recordingTime').textContent = elapsed.toFixed(1) + 's';
                const progress = (elapsed / recordingDuration) * 100;
                document.getElementById('progressFill').style.width = Math.min(progress, 100) + '%';
            }

            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        // Recording functions using MediaRecorder (WebM)
        function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        function startRecording() {
            clearTrajectory();
            
            recordingDuration = parseInt(document.getElementById('recordDuration').value);
            const fps = parseInt(document.getElementById('recordFPS').value);
            const resolution = parseInt(document.getElementById('recordResolution').value);
            
            // Resize for recording
            const width = resolution * 16/9;
            const height = resolution;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            // Create stream from canvas
            stream = renderer.domElement.captureStream(fps);
            
            // Setup MediaRecorder
            recordedChunks = [];
            const options = {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 5000000
            };

            try {
                mediaRecorder = new MediaRecorder(stream, options);
            } catch(e) {
                // Fallback to default codec
                mediaRecorder = new MediaRecorder(stream);
            }

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `attractor-${currentAttractor}-${Date.now()}.webm`;
                link.href = url;
                link.click();
                
                document.getElementById('recordingOverlay').classList.remove('active');
                restoreCanvasSize();
                
                alert('✅ Video exported successfully!');
            };

            mediaRecorder.start();
            isRecording = true;
            recordingStartTime = performance.now();

            // Update UI
            document.getElementById('recordBtn').textContent = '⏹️ STOP RECORDING';
            document.getElementById('recordBtn').classList.add('recording');
            document.getElementById('recordingOverlay').classList.add('active');
            document.getElementById('totalTime').textContent = recordingDuration + 's';
            document.getElementById('recordingStatus').textContent = 'Recording...';

            // Auto-stop after duration
            setTimeout(() => {
                if (isRecording) {
                    stopRecording();
                }
            }, recordingDuration * 1000);
        }

        function stopRecording() {
            isRecording = false;
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }

            document.getElementById('recordBtn').textContent = '🎥 START RECORDING';
            document.getElementById('recordBtn').classList.remove('recording');
            document.getElementById('recordingStatus').textContent = 'Processing...';
        }

        function restoreCanvasSize() {
            const container = document.getElementById('canvas-container');
            renderer.setSize(container.clientWidth, container.clientHeight);
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
        }

        // UI Controls
        function toggleInfiniteMode() {
            infiniteMode = document.getElementById('infiniteMode').checked;
            
            if (infiniteMode) {
                document.getElementById('limitControls').style.display = 'none';
                document.getElementById('infiniteInfo').style.display = 'block';
                document.getElementById('mode-display').textContent = 'Infinite Mode ∞';
                document.getElementById('max-display').textContent = '';
            } else {
                document.getElementById('limitControls').style.display = 'block';
                document.getElementById('infiniteInfo').style.display = 'none';
                document.getElementById('mode-display').textContent = 'Limited Mode';
                document.getElementById('max-display').textContent = ' / ' + maxPoints.toLocaleString();
            }
            
            createLine();
            clearTrajectory();
        }

        function updateMaxPoints() {
            maxPoints = parseInt(document.getElementById('maxPoints').value);
            document.getElementById('maxPointsValue').textContent = maxPoints.toLocaleString();
            document.getElementById('max-display').textContent = ' / ' + maxPoints.toLocaleString();
        }

        function changeAttractor() {
            currentAttractor = document.getElementById('attractorType').value;
            document.getElementById('current-attractor').textContent = 
                document.getElementById('attractorType').selectedOptions[0].text;
            clearTrajectory();
        }

        function quickSwitch(attractor) {
            document.getElementById('attractorType').value = attractor;
            changeAttractor();
        }

        function updateLineWidth() {
            lineWidth = parseFloat(document.getElementById('lineWidth').value);
            document.getElementById('widthValue').textContent = lineWidth;
            if (line) {
                line.material.linewidth = lineWidth;
            }
        }

        function updateSpeed() {
            simulationSpeed = parseFloat(document.getElementById('speed').value);
            document.getElementById('speedValue').textContent = simulationSpeed.toFixed(1) + 'x';
        }

        function updateRotSpeed() {
            const value = parseFloat(document.getElementById('rotSpeed').value);
            rotationSpeed = value * 0.001;
            document.getElementById('rotSpeedValue').textContent = value.toFixed(1);
        }

        function updateColorMode() {
            colorMode = document.getElementById('colorMode').value;
            updateAllColors();
        }

        function updateColors() {
            color1.set(document.getElementById('color1').value);
            color2.set(document.getElementById('color2').value);
            updateAllColors();
        }

        function updateBrightness() {
            brightness = parseFloat(document.getElementById('brightness').value);
            document.getElementById('brightnessValue').textContent = brightness.toFixed(1);
            updateAllColors();
        }

        function updateAllColors() {
            const colorArray = line.geometry.attributes.color.array;
            for (let i = 0; i < points.length; i++) {
                const t = i / Math.max(points.length - 1, 1);
                const color = getColor(points[i], t);
                colorArray[i * 3] = color.r;
                colorArray[i * 3 + 1] = color.g;
                colorArray[i * 3 + 2] = color.b;
            }
            line.geometry.attributes.color.needsUpdate = true;
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
        }

        function resetView() {
            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);
        }

        function clearTrajectory() {
            points = [];
            document.getElementById('point-count').textContent = '0';
            
            const init = attractors[currentAttractor].init;
            x = parseFloat(document.getElementById('initX').value) || init[0];
            y = parseFloat(document.getElementById('initY').value) || init[1];
            z = parseFloat(document.getElementById('initZ').value) || init[2];

            createLine();
        }

        function exportImage(width, height) {
            const container = document.getElementById('canvas-container');
            const origWidth = container.clientWidth;
            const origHeight = container.clientHeight;
            
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.render(scene, camera);
            
            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `attractor-${currentAttractor}-${width}x${height}.png`;
            link.href = dataURL;
            link.click();
            
            setTimeout(() => {
                renderer.setSize(origWidth, origHeight);
                camera.aspect = origWidth / origHeight;
                camera.updateProjectionMatrix();
            }, 100);
        }

        function onWindowResize() {
            if (!isRecording) {
                const container = document.getElementById('canvas-container');
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
