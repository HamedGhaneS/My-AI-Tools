<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎬 Cinematic Strange Attractors</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a3e 100%);
            color: #e0e0e0;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #000;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #controls {
            width: 340px;
            background: rgba(26, 26, 62, 0.95);
            padding: 20px;
            overflow-y: auto;
            border-left: 2px solid #3b82f6;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
        }

        h1 {
            color: #3b82f6;
            font-size: 22px;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #888;
            font-size: 11px;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid #333;
        }

        .control-group {
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 3px solid #3b82f6;
        }

        .control-group h3 {
            color: #3b82f6;
            font-size: 13px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        label {
            display: block;
            color: #aaa;
            font-size: 11px;
            margin-bottom: 4px;
            margin-top: 8px;
        }

        select, input[type="range"], input[type="number"] {
            width: 100%;
            padding: 6px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 12px;
        }

        input[type="range"] {
            padding: 0;
            height: 6px;
        }

        input[type="color"] {
            width: 100%;
            height: 35px;
            border: 2px solid #444;
            border-radius: 5px;
            cursor: pointer;
        }

        input[type="number"] {
            width: 100%;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }

        .checkbox-row label {
            margin: 0;
            flex: 1;
        }

        .value-display {
            float: right;
            color: #3b82f6;
            font-weight: bold;
            font-size: 11px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-top: 8px;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: translateY(-1px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-export {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .btn-record {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .btn-record.recording {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .btn-clear {
            background: linear-gradient(135deg, #6b7280, #4b5563);
        }

        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 8px;
        }

        .preset-btn {
            padding: 6px;
            font-size: 10px;
            margin: 0;
        }

        #info-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid #3b82f6;
            font-size: 11px;
            max-width: 280px;
        }

        #info-overlay h2 {
            color: #3b82f6;
            font-size: 14px;
            margin-bottom: 6px;
        }

        .stats {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #3b82f6;
            font-size: 10px;
            color: #aaa;
        }

        .stats span {
            color: #3b82f6;
            font-weight: bold;
        }

        .recording-overlay {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 20px;
            border-radius: 10px;
            border: 2px solid #ef4444;
            text-align: center;
            display: none;
            z-index: 1000;
            min-width: 280px;
        }

        .recording-overlay.active {
            display: block;
        }

        .recording-dot {
            width: 12px;
            height: 12px;
            background: #ef4444;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            animation: pulse 1s infinite;
        }

        .progress-bar {
            width: 240px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin: 10px auto;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #10b981);
            width: 0%;
            transition: width 0.3s;
        }

        .initial-condition {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 6px;
            margin-top: 8px;
        }

        .initial-condition input {
            padding: 6px;
            font-size: 11px;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: #3b82f6;
            border-radius: 3px;
        }

        .info-text {
            font-size: 10px;
            color: #888;
            line-height: 1.4;
            margin-top: 8px;
            padding: 8px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 4px;
        }

        .info-text.success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #10b981;
        }

        .camera-preview {
            font-size: 10px;
            color: #888;
            margin-top: 5px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="renderCanvas"></canvas>
            <div id="info-overlay">
                <h2>🎬 Cinematic Attractors</h2>
                <p><strong>Current:</strong> <span id="current-attractor">Lorenz</span></p>
                <p style="margin-top: 4px; font-size: 10px; color: #888;">
                    <span id="camera-mode">Manual Control</span>
                </p>
            </div>
            <div class="stats">
                <strong>FPS:</strong> <span id="fps">60</span> | 
                <strong>Points:</strong> <span id="point-count">0</span>
            </div>
            <div class="recording-overlay" id="recordingOverlay">
                <div>
                    <span class="recording-dot"></span>
                    <span style="font-size: 14px; font-weight: bold; color: #ef4444;">REC</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p style="color: #aaa; margin-top: 8px; font-size: 12px;">
                    <span id="recordingTime">0.0s</span> / <span id="totalTime">10s</span>
                </p>
                <p style="color: #888; font-size: 10px; margin-top: 3px;">
                    <span id="recordingStatus">Recording...</span>
                </p>
                <p style="color: #10b981; font-size: 9px; margin-top: 5px;">
                    📹 <span id="cameraAction">Cinematic mode active</span>
                </p>
            </div>
        </div>

        <div id="controls">
            <h1>🎬 Cinematic Mode</h1>
            <p class="subtitle">Professional camera movements + smooth rendering</p>

            <div class="control-group">
                <h3>🎯 Attractor System</h3>
                <select id="attractorType" onchange="changeAttractor()">
                    <option value="lorenz">Lorenz (Butterfly)</option>
                    <option value="rossler">Rössler (Spiral)</option>
                    <option value="aizawa">Aizawa (Complex)</option>
                    <option value="thomas">Thomas (Cyclic)</option>
                    <option value="halvorsen">Halvorsen (4-Wing)</option>
                    <option value="dadras">Dadras (Wings)</option>
                    <option value="chen">Chen (Scrolls)</option>
                    <option value="arneodo">Arneodo (Simple)</option>
                </select>

                <label>Initial Conditions (X, Y, Z)</label>
                <div class="initial-condition">
                    <input type="number" id="initX" value="0.1" step="0.1" placeholder="X">
                    <input type="number" id="initY" value="0" step="0.1" placeholder="Y">
                    <input type="number" id="initZ" value="0" step="0.1" placeholder="Z">
                </div>

                <div class="preset-grid">
                    <button class="preset-btn" onclick="quickSwitch('lorenz')">Lorenz</button>
                    <button class="preset-btn" onclick="quickSwitch('rossler')">Rössler</button>
                    <button class="preset-btn" onclick="quickSwitch('thomas')">Thomas</button>
                    <button class="preset-btn" onclick="quickSwitch('halvorsen')">Halvorsen</button>
                </div>
            </div>

            <div class="control-group">
                <h3>🎨 Visual Quality</h3>
                
                <label>Render Quality</label>
                <select id="renderQuality" onchange="updateRenderQuality()">
                    <option value="1">Standard (Fast)</option>
                    <option value="2" selected>High (Smooth)</option>
                    <option value="3">Ultra (Best for recording)</option>
                </select>

                <label>Line Width <span class="value-display" id="widthValue">2</span></label>
                <input type="range" id="lineWidth" min="1" max="6" value="2" step="0.5" oninput="updateLineWidth()">

                <label>Speed <span class="value-display" id="speedValue">1.0x</span></label>
                <input type="range" id="speed" min="0.5" max="3" value="1" step="0.1" oninput="updateSpeed()">
            </div>

            <div class="control-group">
                <h3>🌈 Colors</h3>
                
                <label>Color Mode</label>
                <select id="colorMode" onchange="updateColorMode()">
                    <option value="gradient">Gradient Flow</option>
                    <option value="rainbow">Rainbow</option>
                    <option value="single">Single Color</option>
                    <option value="dual">Dual Fade</option>
                </select>

                <label>Color 1</label>
                <input type="color" id="color1" value="#00d4ff" oninput="updateColors()">

                <label>Color 2</label>
                <input type="color" id="color2" value="#ff00ff" oninput="updateColors()">

                <label>Brightness <span class="value-display" id="brightnessValue">1.2</span></label>
                <input type="range" id="brightness" min="0.5" max="2" value="1.2" step="0.1" oninput="updateBrightness()">
            </div>

            <div class="control-group">
                <h3>🎬 Manual Camera</h3>
                <button id="autoRotateBtn" onclick="toggleAutoRotate()">
                    🔄 Auto-Rotate: <span id="rotateStatus">OFF</span>
                </button>
                <button class="btn-clear" onclick="resetView()">📷 Reset Camera</button>
                <button class="btn-clear" onclick="clearTrajectory()">🗑️ Clear Trajectory</button>
            </div>

            <div class="control-group">
                <h3>🎥 Record Cinematic Video</h3>
                
                <label>Camera Movement</label>
                <select id="cameraMovement">
                    <option value="orbit">🔄 Orbit Around (Classic)</option>
                    <option value="zoomInOut" selected>🔍 Zoom In & Out (Dramatic)</option>
                    <option value="spiral">🌀 Spiral Motion (Dynamic)</option>
                    <option value="flyby">✈️ Fly-By (Action)</option>
                    <option value="reveal">🎭 Slow Reveal (Cinematic)</option>
                    <option value="dance">💃 Camera Dance (Creative)</option>
                </select>
                <p class="camera-preview" id="cameraPreview">
                    Starts close, zooms out to show full attractor, then zooms back in
                </p>
                
                <label>Duration (seconds)</label>
                <input type="number" id="recordDuration" value="15" min="5" max="120" step="5">
                
                <label>Video Quality</label>
                <select id="videoQuality">
                    <option value="high">High Quality (30 FPS, 8 Mbps)</option>
                    <option value="ultra" selected>Ultra Quality (60 FPS, 12 Mbps)</option>
                </select>

                <label>Resolution</label>
                <select id="recordResolution">
                    <option value="720">720p (1280x720)</option>
                    <option value="1080" selected>1080p (1920x1080)</option>
                    <option value="1440">1440p (2560x1440)</option>
                </select>

                <button class="btn-record" id="recordBtn" onclick="toggleRecording()">
                    🎥 START CINEMATIC RECORDING
                </button>

                <p class="info-text success">
                    ✨ Auto-framed with professional camera movements!
                    <br>🎬 Shows full evolution from start to filled attractor
                </p>
            </div>

            <div class="control-group">
                <h3>📤 Export Image</h3>
                <button class="btn-export" onclick="exportImage(1080, 1080)">📷 Square</button>
                <button class="btn-export" onclick="exportImage(1920, 1080)">🎬 Wide</button>
                <button class="btn-export" onclick="exportImage(3840, 2160)">🖼️ 4K</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        let scene, camera, renderer, line;
        let autoRotate = false;
        let rotationSpeed = 0.005;
        let currentAttractor = 'lorenz';
        let simulationSpeed = 1.0;
        let renderQuality = 2;
        let points = [];
        let lineWidth = 2;
        let x = 0.1, y = 0, z = 0;

        // Color settings
        let colorMode = 'gradient';
        let color1 = new THREE.Color(0x00d4ff);
        let color2 = new THREE.Color(0xff00ff);
        let brightness = 1.2;

        // Recording state
        let isRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = 0;
        let recordingDuration = 15;
        let stream = null;
        let cameraMovement = 'zoomInOut';
        let cinematicMode = false;
        let targetPoints = 0;

        // Camera animation
        let cameraPath = [];
        let cameraAnimationProgress = 0;

        // Attractor parameters
        const attractors = {
            lorenz: {
                step: (x, y, z, dt) => {
                    const sigma = 10, rho = 28, beta = 8/3;
                    return [x + sigma * (y - x) * dt, y + (x * (rho - z) - y) * dt, z + (x * y - beta * z) * dt];
                },
                scale: 0.03,
                init: [0.1, 0, 0]
            },
            rossler: {
                step: (x, y, z, dt) => {
                    const a = 0.2, b = 0.2, c = 5.7;
                    return [x + (-y - z) * dt, y + (x + a * y) * dt, z + (b + z * (x - c)) * dt];
                },
                scale: 0.05,
                init: [0.1, 0, 0]
            },
            aizawa: {
                step: (x, y, z, dt) => {
                    const a = 0.95, b = 0.7, c = 0.6, d = 3.5, e = 0.25, f = 0.1;
                    return [
                        x + ((z - b) * x - d * y) * dt,
                        y + (d * x + (z - b) * y) * dt,
                        z + (c + a * z - z*z*z/3 - (x*x + y*y) * (1 + e * z) + f * z * x*x*x) * dt
                    ];
                },
                scale: 0.2,
                init: [0.1, 0, 0.1]
            },
            thomas: {
                step: (x, y, z, dt) => {
                    const b = 0.208186;
                    return [x + (Math.sin(y) - b * x) * dt, y + (Math.sin(z) - b * y) * dt, z + (Math.sin(x) - b * z) * dt];
                },
                scale: 0.15,
                init: [1, 1, 1]
            },
            halvorsen: {
                step: (x, y, z, dt) => {
                    const a = 1.89;
                    return [
                        x + (-a * x - 4 * y - 4 * z - y * y) * dt,
                        y + (-a * y - 4 * z - 4 * x - z * z) * dt,
                        z + (-a * z - 4 * x - 4 * y - x * x) * dt
                    ];
                },
                scale: 0.08,
                init: [1, 0, 0]
            },
            dadras: {
                step: (x, y, z, dt) => {
                    const a = 3, b = 2.7, c = 1.7, d = 2, e = 9;
                    return [x + (y - a * x + b * y * z) * dt, y + (c * y - x * z + z) * dt, z + (d * x * y - e * z) * dt];
                },
                scale: 0.15,
                init: [1, 1, 1]
            },
            chen: {
                step: (x, y, z, dt) => {
                    const a = 5, b = -10, c = -0.38;
                    return [x + (a * x - y * z) * dt, y + (b * y + x * z) * dt, z + (c * z + x * y / 3) * dt];
                },
                scale: 0.05,
                init: [1, 1, 1]
            },
            arneodo: {
                step: (x, y, z, dt) => {
                    const a = -5.5, b = 3.5, c = -1;
                    return [x + y * dt, y + z * dt, z + (-a * x - b * y - z + c * x*x*x) * dt];
                },
                scale: 0.08,
                init: [0.1, 0, 0]
            }
        };

        // Camera movement descriptions
        const cameraDescriptions = {
            orbit: "Smooth 360° orbit around the attractor at constant distance",
            zoomInOut: "Starts close, zooms out to show full attractor, then zooms back in",
            spiral: "Spirals around while gradually changing height and distance",
            flyby: "Fast dynamic fly-by from multiple angles like action cinematography",
            reveal: "Slow dramatic reveal from darkness, pulling back to show full beauty",
            dance: "Fluid S-curve movements with varying speeds for artistic effect"
        };

        // Update camera preview
        document.getElementById('cameraMovement').addEventListener('change', function() {
            const movement = this.value;
            document.getElementById('cameraPreview').textContent = cameraDescriptions[movement];
        });

        function init() {
            const canvas = document.getElementById('renderCanvas');
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(0, 0, 5);

            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            createLine();
            setupControls();
            
            const init = attractors[currentAttractor].init;
            x = parseFloat(document.getElementById('initX').value) || init[0];
            y = parseFloat(document.getElementById('initY').value) || init[1];
            z = parseFloat(document.getElementById('initZ').value) || init[2];

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createLine() {
            const initialSize = 100000;
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(initialSize * 3);
            const colors = new Float32Array(initialSize * 3);
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                linewidth: lineWidth,
                transparent: false,
                opacity: 1.0
            });

            if (line) {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            }

            line = new THREE.Line(geometry, material);
            scene.add(line);
        }

        function updateAttractor() {
            // Stop if reached target during recording
            if (isRecording && points.length >= targetPoints) {
                return;
            }

            const attractor = attractors[currentAttractor];
            const dt = 0.005 * simulationSpeed;
            
            // Multiple steps per frame for smoothness
            for (let i = 0; i < renderQuality; i++) {
                const [newX, newY, newZ] = attractor.step(x, y, z, dt);
                
                if (!isFinite(newX) || !isFinite(newY) || !isFinite(newZ)) continue;
                
                x = newX;
                y = newY;
                z = newZ;

                const scaledPoint = new THREE.Vector3(
                    x * attractor.scale,
                    y * attractor.scale,
                    z * attractor.scale
                );
                
                points.push(scaledPoint);
            }

            document.getElementById('point-count').textContent = points.length.toLocaleString();

            // Update geometry
            const positions = line.geometry.attributes.position.array;
            const colorArray = line.geometry.attributes.color.array;
            
            for (let i = Math.max(0, points.length - renderQuality * 10); i < points.length; i++) {
                const point = points[i];
                positions[i * 3] = point.x;
                positions[i * 3 + 1] = point.y;
                positions[i * 3 + 2] = point.z;

                const t = i / Math.max(points.length - 1, 1);
                const color = getColor(point, t);
                colorArray[i * 3] = color.r;
                colorArray[i * 3 + 1] = color.g;
                colorArray[i * 3 + 2] = color.b;
            }

            line.geometry.setDrawRange(0, points.length);
            line.geometry.attributes.position.needsUpdate = true;
            line.geometry.attributes.color.needsUpdate = true;
        }

        function getColor(point, t) {
            const color = new THREE.Color();

            switch(colorMode) {
                case 'gradient':
                    const mag = Math.sqrt(point.x*point.x + point.y*point.y + point.z*point.z);
                    const normalized = Math.min(mag * 2, 1);
                    color.lerpColors(color1, color2, normalized);
                    break;
                case 'rainbow':
                    color.setHSL(t, 1, 0.5);
                    break;
                case 'single':
                    color.copy(color1);
                    break;
                case 'dual':
                    color.lerpColors(color1, color2, t);
                    break;
            }

            color.multiplyScalar(brightness);
            return color;
        }

        // Generate camera path based on movement type
        function generateCameraPath(movement, duration) {
            const steps = Math.floor(duration * 60); // 60 fps
            const path = [];
            
            switch(movement) {
                case 'orbit':
                    for (let i = 0; i < steps; i++) {
                        const t = i / steps;
                        const angle = t * Math.PI * 2;
                        const radius = 5;
                        path.push({
                            position: new THREE.Vector3(
                                Math.cos(angle) * radius,
                                Math.sin(angle * 0.5) * 2,
                                Math.sin(angle) * radius
                            ),
                            lookAt: new THREE.Vector3(0, 0, 0)
                        });
                    }
                    break;

                case 'zoomInOut':
                    for (let i = 0; i < steps; i++) {
                        const t = i / steps;
                        let distance;
                        if (t < 0.3) {
                            distance = 2 + t * 10; // Zoom out
                        } else if (t < 0.7) {
                            distance = 5 + Math.sin((t - 0.3) * Math.PI * 2) * 3; // Orbit
                        } else {
                            distance = 8 - (t - 0.7) * 15; // Zoom in
                        }
                        const angle = t * Math.PI * 1.5;
                        path.push({
                            position: new THREE.Vector3(
                                Math.cos(angle) * distance,
                                Math.sin(t * Math.PI) * 2,
                                Math.sin(angle) * distance
                            ),
                            lookAt: new THREE.Vector3(0, 0, 0)
                        });
                    }
                    break;

                case 'spiral':
                    for (let i = 0; i < steps; i++) {
                        const t = i / steps;
                        const angle = t * Math.PI * 4;
                        const radius = 3 + Math.sin(t * Math.PI * 2) * 2;
                        const height = Math.cos(t * Math.PI * 2) * 3;
                        path.push({
                            position: new THREE.Vector3(
                                Math.cos(angle) * radius,
                                height,
                                Math.sin(angle) * radius
                            ),
                            lookAt: new THREE.Vector3(0, 0, 0)
                        });
                    }
                    break;

                case 'flyby':
                    for (let i = 0; i < steps; i++) {
                        const t = i / steps;
                        const angle = t * Math.PI * 3;
                        const radius = 3 + Math.abs(Math.sin(t * Math.PI * 4)) * 4;
                        const height = Math.sin(t * Math.PI * 6) * 3;
                        path.push({
                            position: new THREE.Vector3(
                                Math.cos(angle) * radius,
                                height,
                                Math.sin(angle) * radius
                            ),
                            lookAt: new THREE.Vector3(0, 0, 0)
                        });
                    }
                    break;

                case 'reveal':
                    for (let i = 0; i < steps; i++) {
                        const t = i / steps;
                        const easeT = t * t * (3 - 2 * t); // Smooth ease
                        const distance = 1 + easeT * 7;
                        const angle = easeT * Math.PI * 0.5;
                        path.push({
                            position: new THREE.Vector3(
                                Math.cos(angle) * distance,
                                easeT * 2,
                                Math.sin(angle) * distance
                            ),
                            lookAt: new THREE.Vector3(0, 0, 0)
                        });
                    }
                    break;

                case 'dance':
                    for (let i = 0; i < steps; i++) {
                        const t = i / steps;
                        const angle1 = Math.sin(t * Math.PI * 3) * Math.PI;
                        const angle2 = Math.cos(t * Math.PI * 2) * Math.PI;
                        const radius = 4 + Math.sin(t * Math.PI * 4) * 2;
                        path.push({
                            position: new THREE.Vector3(
                                Math.cos(angle1) * radius,
                                Math.sin(angle2) * 2,
                                Math.sin(angle1) * radius
                            ),
                            lookAt: new THREE.Vector3(0, 0, 0)
                        });
                    }
                    break;
            }
            
            return path;
        }

        function updateCinematicCamera() {
            if (!cinematicMode || cameraPath.length === 0) return;

            const index = Math.floor(cameraAnimationProgress);
            const nextIndex = Math.min(index + 1, cameraPath.length - 1);
            const t = cameraAnimationProgress - index;

            // Smooth interpolation
            const current = cameraPath[index];
            const next = cameraPath[nextIndex];

            camera.position.lerpVectors(current.position, next.position, t);
            
            const lookAtCurrent = current.lookAt;
            const lookAtNext = next.lookAt;
            const lookAtInterpolated = new THREE.Vector3().lerpVectors(lookAtCurrent, lookAtNext, t);
            camera.lookAt(lookAtInterpolated);

            // Advance animation
            const recordedTime = (performance.now() - recordingStartTime) / 1000;
            const progressFraction = recordedTime / recordingDuration;
            cameraAnimationProgress = progressFraction * (cameraPath.length - 1);

            // Update status
            const movements = {
                orbit: 'Orbiting',
                zoomInOut: progressFraction < 0.3 ? 'Zooming out' : progressFraction < 0.7 ? 'Orbiting' : 'Zooming in',
                spiral: 'Spiraling',
                flyby: 'Flying by',
                reveal: 'Revealing',
                dance: 'Dancing'
            };
            document.getElementById('cameraAction').textContent = movements[cameraMovement] || 'Moving';
        }

        function setupControls() {
            const canvas = renderer.domElement;
            let isDragging = false;
            let previousMouse = { x: 0, y: 0 };

            canvas.addEventListener('mousedown', (e) => {
                if (!cinematicMode) {
                    isDragging = true;
                    previousMouse = { x: e.clientX, y: e.clientY };
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging && !cinematicMode) {
                    const deltaX = e.clientX - previousMouse.x;
                    const deltaY = e.clientY - previousMouse.y;

                    const rotMatrix = new THREE.Matrix4();
                    rotMatrix.makeRotationY(deltaX * 0.005);
                    camera.position.applyMatrix4(rotMatrix);

                    const axis = new THREE.Vector3(1, 0, 0);
                    axis.applyMatrix4(new THREE.Matrix4().makeRotationY(
                        Math.atan2(camera.position.x, camera.position.z)
                    ));
                    rotMatrix.makeRotationAxis(axis, deltaY * 0.005);
                    camera.position.applyMatrix4(rotMatrix);

                    camera.lookAt(0, 0, 0);
                    previousMouse = { x: e.clientX, y: e.clientY };
                }
            });

            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);

            canvas.addEventListener('wheel', (e) => {
                if (!cinematicMode) {
                    e.preventDefault();
                    const delta = e.deltaY * 0.001;
                    const direction = camera.position.clone().normalize();
                    camera.position.addScaledVector(direction, delta);
                    camera.position.clampLength(1.5, 20);
                }
            });
        }

        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;

        function animate() {
            requestAnimationFrame(animate);

            updateAttractor();

            // Camera control
            if (cinematicMode) {
                updateCinematicCamera();
            } else if (autoRotate) {
                const rotMatrix = new THREE.Matrix4();
                rotMatrix.makeRotationY(rotationSpeed);
                camera.position.applyMatrix4(rotMatrix);
                camera.lookAt(0, 0, 0);
            }

            renderer.render(scene, camera);

            // Update recording progress
            if (isRecording) {
                const elapsed = (performance.now() - recordingStartTime) / 1000;
                document.getElementById('recordingTime').textContent = elapsed.toFixed(1) + 's';
                const progress = (elapsed / recordingDuration) * 100;
                document.getElementById('progressFill').style.width = Math.min(progress, 100) + '%';
            }

            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        function startRecording() {
            clearTrajectory();
            
            recordingDuration = parseInt(document.getElementById('recordDuration').value);
            cameraMovement = document.getElementById('cameraMovement').value;
            const quality = document.getElementById('videoQuality').value;
            const resolution = parseInt(document.getElementById('recordResolution').value);
            
            // Calculate target points
            targetPoints = recordingDuration * 60 * renderQuality * 3;
            
            // Generate camera path
            cameraPath = generateCameraPath(cameraMovement, recordingDuration);
            cameraAnimationProgress = 0;
            cinematicMode = true;

            // Set quality
            const fps = quality === 'ultra' ? 60 : 30;
            const bitrate = quality === 'ultra' ? 12000000 : 8000000;
            
            // Resize for recording
            let width, height;
            if (resolution === 720) {
                width = 1280;
                height = 720;
            } else if (resolution === 1080) {
                width = 1920;
                height = 1080;
            } else {
                width = 2560;
                height = 1440;
            }
            
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            // Create stream
            stream = renderer.domElement.captureStream(fps);
            
            // Setup MediaRecorder
            recordedChunks = [];
            const options = {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: bitrate
            };

            try {
                mediaRecorder = new MediaRecorder(stream, options);
            } catch(e) {
                mediaRecorder = new MediaRecorder(stream);
            }

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `cinematic-${currentAttractor}-${Date.now()}.webm`;
                link.href = url;
                link.click();
                
                document.getElementById('recordingOverlay').classList.remove('active');
                cinematicMode = false;
                restoreCanvasSize();
                
                alert('✅ Cinematic video exported successfully!');
            };

            mediaRecorder.start();
            isRecording = true;
            recordingStartTime = performance.now();

            // UI updates
            document.getElementById('recordBtn').textContent = '⏹️ STOP RECORDING';
            document.getElementById('recordBtn').classList.add('recording');
            document.getElementById('recordingOverlay').classList.add('active');
            document.getElementById('totalTime').textContent = recordingDuration + 's';
            document.getElementById('recordingStatus').textContent = 'Recording...';
            document.getElementById('camera-mode').textContent = '🎬 Cinematic Mode';

            // Auto-stop
            setTimeout(() => {
                if (isRecording) {
                    stopRecording();
                }
            }, recordingDuration * 1000);
        }

        function stopRecording() {
            isRecording = false;
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }

            document.getElementById('recordBtn').textContent = '🎥 START CINEMATIC RECORDING';
            document.getElementById('recordBtn').classList.remove('recording');
            document.getElementById('recordingStatus').textContent = 'Processing...';
            document.getElementById('camera-mode').textContent = 'Manual Control';
        }

        function restoreCanvasSize() {
            const container = document.getElementById('canvas-container');
            renderer.setSize(container.clientWidth, container.clientHeight);
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
        }

        // UI Controls
        function updateRenderQuality() {
            renderQuality = parseInt(document.getElementById('renderQuality').value);
        }

        function changeAttractor() {
            currentAttractor = document.getElementById('attractorType').value;
            document.getElementById('current-attractor').textContent = 
                document.getElementById('attractorType').selectedOptions[0].text;
            clearTrajectory();
        }

        function quickSwitch(attractor) {
            document.getElementById('attractorType').value = attractor;
            changeAttractor();
        }

        function updateLineWidth() {
            lineWidth = parseFloat(document.getElementById('lineWidth').value);
            document.getElementById('widthValue').textContent = lineWidth;
            if (line) line.material.linewidth = lineWidth;
        }

        function updateSpeed() {
            simulationSpeed = parseFloat(document.getElementById('speed').value);
            document.getElementById('speedValue').textContent = simulationSpeed.toFixed(1) + 'x';
        }

        function updateColorMode() {
            colorMode = document.getElementById('colorMode').value;
            updateAllColors();
        }

        function updateColors() {
            color1.set(document.getElementById('color1').value);
            color2.set(document.getElementById('color2').value);
            updateAllColors();
        }

        function updateBrightness() {
            brightness = parseFloat(document.getElementById('brightness').value);
            document.getElementById('brightnessValue').textContent = brightness.toFixed(1);
            updateAllColors();
        }

        function updateAllColors() {
            const colorArray = line.geometry.attributes.color.array;
            for (let i = 0; i < points.length; i++) {
                const t = i / Math.max(points.length - 1, 1);
                const color = getColor(points[i], t);
                colorArray[i * 3] = color.r;
                colorArray[i * 3 + 1] = color.g;
                colorArray[i * 3 + 2] = color.b;
            }
            line.geometry.attributes.color.needsUpdate = true;
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            const btn = document.getElementById('autoRotateBtn');
            const status = document.getElementById('rotateStatus');
            
            if (autoRotate) {
                status.textContent = 'ON';
                btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
            } else {
                status.textContent = 'OFF';
                btn.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
            }
        }

        function resetView() {
            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);
        }

        function clearTrajectory() {
            points = [];
            document.getElementById('point-count').textContent = '0';
            
            const init = attractors[currentAttractor].init;
            x = parseFloat(document.getElementById('initX').value) || init[0];
            y = parseFloat(document.getElementById('initY').value) || init[1];
            z = parseFloat(document.getElementById('initZ').value) || init[2];

            createLine();
        }

        function exportImage(width, height) {
            const container = document.getElementById('canvas-container');
            const origWidth = container.clientWidth;
            const origHeight = container.clientHeight;
            
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.render(scene, camera);
            
            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `attractor-${currentAttractor}-${width}x${height}.png`;
            link.href = dataURL;
            link.click();
            
            setTimeout(() => {
                renderer.setSize(origWidth, origHeight);
                camera.aspect = origWidth / origHeight;
                camera.updateProjectionMatrix();
            }, 100);
        }

        function onWindowResize() {
            if (!isRecording) {
                const container = document.getElementById('canvas-container');
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
