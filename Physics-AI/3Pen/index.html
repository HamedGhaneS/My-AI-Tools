<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triple Pendulum Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #0f4c75;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.3);
            background: #0a0e27;
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #e0e0e0;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #0f4c75;
        }
        .info h2 {
            margin: 0 0 10px 0;
            color: #3b82f6;
        }
        .info p {
            margin: 5px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="info">
        <h2>üéØ Triple Pendulum</h2>
        <p><span style="color: #ef4444;">‚îÅ‚îÅ</span> Pendulum 1</p>
        <p><span style="color: #3b82f6;">‚îÅ‚îÅ</span> Pendulum 2</p>
        <p><span style="color: #10b981;">‚îÅ‚îÅ</span> Pendulum 3</p>
        <p style="margin-top: 10px; color: #888;">Demonstrating chaotic motion</p>
    </div>
    <canvas id="pendulumCanvas"></canvas>

    <script>
        const canvas = document.getElementById('pendulumCanvas');
        const ctx = canvas.getContext('2d');
        
        // Canvas dimensions
        canvas.width = 900;
        canvas.height = 700;
        
        // Physics constants
        const g = 9.81;  // Gravitational acceleration (m/s¬≤)
        const dampingFactor = 0.9995;  // Air resistance (minimal damping for chaotic behavior)
        
        // Pendulum properties
        const pendulum = {
            // Masses (kg)
            m1: 1.0,
            m2: 1.0,
            m3: 1.0,
            
            // Lengths (pixels, representing meters)
            L1: 150,
            L2: 150,
            L3: 150,
            
            // Angles from vertical (radians)
            theta1: Math.PI / 2,      // Start at 90 degrees
            theta2: Math.PI / 2 + 0.1,
            theta3: Math.PI / 2 + 0.2,
            
            // Angular velocities (rad/s)
            omega1: 0,
            omega2: 0,
            omega3: 0,
            
            // Origin point (pivot)
            originX: canvas.width / 2,
            originY: 100
        };
        
        // Trail storage for each pendulum joint
        const trail1 = [];
        const trail2 = [];
        const trail3 = [];
        const maxTrailLength = 200;
        
        // Colors for each pendulum
        const colors = {
            pendulum1: '#ef4444',
            pendulum2: '#3b82f6',
            pendulum3: '#10b981',
            pivot: '#fbbf24'
        };
        
        // Time step for numerical integration (smaller = more accurate but slower)
        const dt = 0.015;
        
        /**
         * Calculate angular accelerations using Lagrangian mechanics
         * Returns [alpha1, alpha2, alpha3] - angular accelerations
         * 
         * These equations are derived from the Euler-Lagrange equations:
         * d/dt(‚àÇL/‚àÇœâ) - ‚àÇL/‚àÇŒ∏ = 0
         * where L = T - V (kinetic - potential energy)
         */
        function calculateAccelerations(theta1, theta2, theta3, omega1, omega2, omega3) {
            const {m1, m2, m3, L1, L2, L3} = pendulum;
            
            // Simplify notation
            const c12 = Math.cos(theta1 - theta2);  // cos(Œ∏1 - Œ∏2)
            const c13 = Math.cos(theta1 - theta3);
            const c23 = Math.cos(theta2 - theta3);
            const s12 = Math.sin(theta1 - theta2);  // sin(Œ∏1 - Œ∏2)
            const s13 = Math.sin(theta1 - theta3);
            const s23 = Math.sin(theta2 - theta3);
            const s1 = Math.sin(theta1);
            const s2 = Math.sin(theta2);
            const s3 = Math.sin(theta3);
            
            // Total mass factors
            const M1 = m1 + m2 + m3;
            const M2 = m2 + m3;
            
            // Mass matrix elements (from kinetic energy terms)
            const a11 = M1 * L1 * L1;
            const a12 = M2 * L1 * L2 * c12;
            const a13 = m3 * L1 * L3 * c13;
            const a22 = M2 * L2 * L2;
            const a23 = m3 * L2 * L3 * c23;
            const a33 = m3 * L3 * L3;
            
            // Right-hand side terms (from potential energy gradient + centrifugal terms)
            const f1 = -M1 * g * L1 * s1 
                      - M2 * L1 * L2 * omega2 * omega2 * s12
                      - m3 * L1 * L3 * omega3 * omega3 * s13;
                      
            const f2 = -M2 * g * L2 * s2
                      + M2 * L1 * L2 * omega1 * omega1 * s12
                      - m3 * L2 * L3 * omega3 * omega3 * s23;
                      
            const f3 = -m3 * g * L3 * s3
                      + m3 * L1 * L3 * omega1 * omega1 * s13
                      + m3 * L2 * L3 * omega2 * omega2 * s23;
            
            // Solve the linear system: A * alpha = f
            // Using Cramer's rule for 3x3 system
            const det = a11 * (a22 * a33 - a23 * a23) 
                       - a12 * (a12 * a33 - a23 * a13) 
                       + a13 * (a12 * a23 - a22 * a13);
            
            if (Math.abs(det) < 1e-10) {
                // Singular matrix - return zero accelerations
                return [0, 0, 0];
            }
            
            // Calculate angular accelerations using Cramer's rule
            const det1 = f1 * (a22 * a33 - a23 * a23)
                        - a12 * (f2 * a33 - a23 * f3)
                        + a13 * (f2 * a23 - a22 * f3);
                        
            const det2 = a11 * (f2 * a33 - a23 * f3)
                        - f1 * (a12 * a33 - a23 * a13)
                        + a13 * (a12 * f3 - f2 * a13);
                        
            const det3 = a11 * (a22 * f3 - f2 * a23)
                        - a12 * (a12 * f3 - f2 * a13)
                        + f1 * (a12 * a23 - a22 * a13);
            
            const alpha1 = det1 / det;
            const alpha2 = det2 / det;
            const alpha3 = det3 / det;
            
            return [alpha1, alpha2, alpha3];
        }
        
        /**
         * Runge-Kutta 4th order integration for smooth, accurate motion
         * This is a standard numerical method for solving ODEs
         */
        function integrateRK4() {
            const state = [
                pendulum.theta1, pendulum.theta2, pendulum.theta3,
                pendulum.omega1, pendulum.omega2, pendulum.omega3
            ];
            
            // RK4 requires 4 evaluations per step
            const k1 = derivatives(state);
            const k2 = derivatives(state.map((s, i) => s + 0.5 * dt * k1[i]));
            const k3 = derivatives(state.map((s, i) => s + 0.5 * dt * k2[i]));
            const k4 = derivatives(state.map((s, i) => s + dt * k3[i]));
            
            // Weighted average: (k1 + 2*k2 + 2*k3 + k4) / 6
            for (let i = 0; i < state.length; i++) {
                state[i] += (dt / 6) * (k1[i] + 2*k2[i] + 2*k3[i] + k4[i]);
            }
            
            // Update pendulum state
            pendulum.theta1 = state[0];
            pendulum.theta2 = state[1];
            pendulum.theta3 = state[2];
            pendulum.omega1 = state[3] * dampingFactor;  // Apply damping
            pendulum.omega2 = state[4] * dampingFactor;
            pendulum.omega3 = state[5] * dampingFactor;
        }
        
        /**
         * Calculate derivatives for the system
         * Returns [dŒ∏1/dt, dŒ∏2/dt, dŒ∏3/dt, dœâ1/dt, dœâ2/dt, dœâ3/dt]
         */
        function derivatives(state) {
            const [theta1, theta2, theta3, omega1, omega2, omega3] = state;
            const [alpha1, alpha2, alpha3] = calculateAccelerations(
                theta1, theta2, theta3, omega1, omega2, omega3
            );
            
            // dŒ∏/dt = œâ, dœâ/dt = Œ±
            return [omega1, omega2, omega3, alpha1, alpha2, alpha3];
        }
        
        /**
         * Calculate Cartesian positions of each mass
         */
        function getPositions() {
            const {originX, originY, L1, L2, L3, theta1, theta2, theta3} = pendulum;
            
            // Position of mass 1
            const x1 = originX + L1 * Math.sin(theta1);
            const y1 = originY + L1 * Math.cos(theta1);
            
            // Position of mass 2 (relative to mass 1)
            const x2 = x1 + L2 * Math.sin(theta2);
            const y2 = y1 + L2 * Math.cos(theta2);
            
            // Position of mass 3 (relative to mass 2)
            const x3 = x2 + L3 * Math.sin(theta3);
            const y3 = y2 + L3 * Math.cos(theta3);
            
            return {
                pivot: {x: originX, y: originY},
                mass1: {x: x1, y: y1},
                mass2: {x: x2, y: y2},
                mass3: {x: x3, y: y3}
            };
        }
        
        /**
         * Draw fading trail for chaotic motion visualization
         */
        function drawTrail(trail, color) {
            if (trail.length < 2) return;
            
            for (let i = 1; i < trail.length; i++) {
                const alpha = i / trail.length;  // Fade from 0 to 1
                ctx.strokeStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(trail[i-1].x, trail[i-1].y);
                ctx.lineTo(trail[i].x, trail[i].y);
                ctx.stroke();
            }
        }
        
        /**
         * Draw the pendulum system
         */
        function draw() {
            // Clear canvas with slight transparency for trail effect
            ctx.fillStyle = 'rgba(10, 14, 39, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const pos = getPositions();
            
            // Add current positions to trails
            trail1.push({x: pos.mass1.x, y: pos.mass1.y});
            trail2.push({x: pos.mass2.x, y: pos.mass2.y});
            trail3.push({x: pos.mass3.x, y: pos.mass3.y});
            
            // Limit trail length
            if (trail1.length > maxTrailLength) trail1.shift();
            if (trail2.length > maxTrailLength) trail2.shift();
            if (trail3.length > maxTrailLength) trail3.shift();
            
            // Draw trails (oldest to newest for proper fading)
            drawTrail(trail1, colors.pendulum1);
            drawTrail(trail2, colors.pendulum2);
            drawTrail(trail3, colors.pendulum3);
            
            // Draw pendulum rods
            ctx.lineWidth = 3;
            
            // Rod 1
            ctx.strokeStyle = colors.pendulum1;
            ctx.beginPath();
            ctx.moveTo(pos.pivot.x, pos.pivot.y);
            ctx.lineTo(pos.mass1.x, pos.mass1.y);
            ctx.stroke();
            
            // Rod 2
            ctx.strokeStyle = colors.pendulum2;
            ctx.beginPath();
            ctx.moveTo(pos.mass1.x, pos.mass1.y);
            ctx.lineTo(pos.mass2.x, pos.mass2.y);
            ctx.stroke();
            
            // Rod 3
            ctx.strokeStyle = colors.pendulum3;
            ctx.beginPath();
            ctx.moveTo(pos.mass2.x, pos.mass2.y);
            ctx.lineTo(pos.mass3.x, pos.mass3.y);
            ctx.stroke();
            
            // Draw masses (circles)
            const drawMass = (x, y, color, radius = 10) => {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
            };
            
            drawMass(pos.pivot.x, pos.pivot.y, colors.pivot, 8);
            drawMass(pos.mass1.x, pos.mass1.y, colors.pendulum1, 12);
            drawMass(pos.mass2.x, pos.mass2.y, colors.pendulum2, 12);
            drawMass(pos.mass3.x, pos.mass3.y, colors.pendulum3, 12);
        }
        
        /**
         * Animation loop
         */
        function animate() {
            integrateRK4();  // Update physics
            draw();          // Render
            requestAnimationFrame(animate);
        }
        
        // Start simulation automatically
        animate();
    </script>
</body>
</html>
